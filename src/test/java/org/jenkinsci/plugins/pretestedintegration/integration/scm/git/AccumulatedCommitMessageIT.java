package org.jenkinsci.plugins.pretestedintegration.integration.scm.git;

import hudson.model.FreeStyleBuild;
import hudson.model.FreeStyleProject;
import hudson.util.RunList;
import java.io.File;
import static junit.framework.TestCase.assertEquals;
import org.apache.commons.io.FileUtils;
import org.eclipse.jgit.api.CommitCommand;
import org.eclipse.jgit.api.CreateBranchCommand;
import org.eclipse.jgit.api.CreateBranchCommand.SetupUpstreamMode;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.MergeCommand;
import org.eclipse.jgit.internal.storage.file.FileRepository;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.revwalk.RevCommit;
import org.junit.After;
import org.junit.Rule;
import org.junit.Test;
import org.jvnet.hudson.test.JenkinsRule;

/*
Test cases for that accumulated commit message is correct constructed
from the commits merged into the integration branch.

The Pretested Integration plugin will use the almost same commit message for an
accumulated commit as if the commit message was automatically generated by a
squash commit.
Such a message is basically constructed from the collection of the log messages
for a commit included.

The following two commits will be squashed as shown below:
----------------------------------------------------------
commit 39f1c99d6655f62cb3441f60dbebddba10872f12
Author: john Doe <Joh@praqma.net>
Date:   Mon Mar 2 18:04:17 2015 +0100

    Updated infofile file again on branch ready/myfeature
    
    - my first change is about this
    - my next change is a refactor.

commit 2953be791fc17f218dc941215b6027de0b985b75
Author: john Doe <Joh@praqma.net>
Date:   Mon Mar 2 18:04:17 2015 +0100

    Updated infofile file on branch ready/myfeature

--------------------------------------------------------------------------------

The squashed commit will be (shown with git log):
-------------------------------------------------
commit 5a365f1604396149a006ef3ba0671e05e380028d
Author: john Doe <Joh@praqma.net>
Date:   Mon Mar 2 18:05:47 2015 +0100

    Squashed commit of the following:
    
    commit 39f1c99d6655f62cb3441f60dbebddba10872f12
    Author: john Doe <Joh@praqma.net>
    Date:   Mon Mar 2 18:04:17 2015 +0100
    
        Updated infofile file again on branch ready/myfeature
    
        - my first change is about this
        - my next change is a refactor.
    
    commit 2953be791fc17f218dc941215b6027de0b985b75
    Author: john Doe <Joh@praqma.net>
    Date:   Mon Mar 2 18:04:17 2015 +0100
    
        Updated infofile file on branch ready/myfeature

--------------------------------------------------------------------------------

The accumulated strategy should be almost identical, only first line changed:
------------------------------------------------------------------------------
commit 5a365f1604396149a006ef3ba0671e05e380028d
Author: john Doe <Joh@praqma.net>
Date:   Mon Mar 2 18:05:47 2015 +0100

    Accumulated commit of the following from branch 'ready/myfeature':
    
    commit 39f1c99d6655f62cb3441f60dbebddba10872f12
    Author: john Doe <Joh@praqma.net>
    Date:   Mon Mar 2 18:04:17 2015 +0100
    
        Updated infofile file again on branch ready/myfeature
    
        - my first change is about this
        - my next change is a refactor.
    
    commit 2953be791fc17f218dc941215b6027de0b985b75
    Author: john Doe <Joh@praqma.net>
    Date:   Mon Mar 2 18:04:17 2015 +0100
    
        Updated infofile file on branch ready/myfeature

--------------------------------------------------------------------------------
*/
public class AccumulatedCommitMessageIT {
    
    @Rule
    public JenkinsRule jenkinsRule = new JenkinsRule();

    private Repository bareRepository;
    public static final String AUTHOR_NAME = "john Doe";
    public static final String AUTHOR_EMAIL = "Joh@praqma.net";

    @After
    public void tearDown() throws Exception {        
        TestUtilsFactory.destroyRepo(bareRepository);        
    }

    
    
    /*
    Test flow
    * construct repository, with feature branch based on master (see below)
    * make accumulated merge
    * verify that merge commit message contains the relevant commits

    Verification is done by searching the merge commit message for unique strings,
    which is supposed to be there because the accumulated commits have these 
    in their commit messages.
    
    Test also verified expected number of commits on master, after integration.
    
    This is the simplest scenario.
    
    
    The constructed repository looks like this seen from the master branch:
    ----------------------------------------------------------------------------
    * 4451bda - (HEAD, origin/ready/myfeature, ready/myfeature) Updated infofile file again on branch ready/myfeature <john Doe>
    * 7933d8b - Updated infofile file on branch ready/myfeature <john Doe>
    * 7770f99 - (origin/master, master) Updated infofile file on branch master <john Doe>
    * bb407fc - Readme file created on branch master <john Doe>
    ----------------------------------------------------------------------------
    
    This is liniar history, with first two commits on master, then branching out
    doing two more commit and the branch.
    
    After the accumulated commit of the two commits 7933d8b, 4451bda on
    branch ready/myfeature it will look like this:
    ----------------------------------------------------------------------------
    *   49939e9 - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/myfeature': <John Doe>
    |\  
    | * 4451bda - (origin/ready/myfeature, ready/myfeature) Updated infofile file again on branch ready/myfeature <john Doe>
    | * 7933d8b - Updated infofile file on branch ready/myfeature <john Doe>
    |/  
    * 7770f99 - Updated infofile file on branch master <john Doe>
    * bb407fc - Readme file created on branch master <john Doe>
    ----------------------------------------------------------------------------
    */
    @Test
    public void mergeCommitContainsAllMessagesFromTheFeatureBranch() throws Exception {
        /**********************************************************************
         * Prepare repository to use for testing
         **********************************************************************/
        String REPO_FOLDER_NAME = "mergeCommitContainsAllMessagesFromTheFeatureBranch";
        String FEATURE_BRANCH_NAME = "ready/myfeature";

        File bareRepoPath = new File(REPO_FOLDER_NAME + ".git");
        bareRepository = new FileRepository(bareRepoPath);        
        bareRepository.create(true);
        
        File workingRepoPath = new File(REPO_FOLDER_NAME);

        // clone bare repository
        Git.cloneRepository().setURI("file:///"+bareRepoPath.getAbsolutePath()).setDirectory(workingRepoPath)
        .setBare(false)
        .setCloneAllBranches(true)                
        .setNoCheckout(false)
        .call().close();
        // Open it to add stuff below
        Git gitrepo = Git.open(workingRepoPath);

        // commits on branch master
        File readme = new File(workingRepoPath,"readme");
        FileUtils.writeStringToFile(readme, String.format("First line in readme file%n"), true);
        gitrepo.add().addFilepattern(readme.getName()).call();
        CommitCommand commitCommand = gitrepo.commit();
        commitCommand.setMessage("Readme file created on branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
        
        FileUtils.writeStringToFile(readme, String.format("Second line in readme file%n"), true);
        gitrepo.add().addFilepattern(readme.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage("Updated readme file on branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
        
        // change to feature branch and do changes there
        CreateBranchCommand createBranchCommand = gitrepo.branchCreate();
        createBranchCommand.setName(FEATURE_BRANCH_NAME);
        createBranchCommand.call();
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();

        FileUtils.writeStringToFile(readme, String.format("Third line in readme file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(readme.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Updated readme file on branch %s", FEATURE_BRANCH_NAME));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        RevCommit revCommit = commitCommand.call();
        String featureCommit1SHA = revCommit.getId().getName();
        System.out.println("featureCommit1SHA: " + featureCommit1SHA);
        

        FileUtils.writeStringToFile(readme, String.format("Fourth line in readme file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(readme.getName()).call();
        commitCommand = gitrepo.commit();
        String multiLineCommitMessage = String.format("%n%n- my first change is about this%n- my next change is a refactor.");
        commitCommand.setMessage(String.format("Updated readme file again on branch %s%s", FEATURE_BRANCH_NAME, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String featureCommit2SHA = revCommit.getId().getName();
        System.out.println("featureCommit2SHA: " + featureCommit2SHA);

        // push all changes, so the end in the bare repository that our Jenkins test below will use
        gitrepo.push().setPushAll().call();        
        
       
        /**********************************************************************
         * Run test with Jenkins job trying to integrate the feature branch
         **********************************************************************/
        FreeStyleProject project = TestUtilsFactory.configurePretestedIntegrationPlugin(jenkinsRule, TestUtilsFactory.STRATEGY_TYPE.ACCUMULATED, bareRepository);
        TestUtilsFactory.triggerProject(project);
        jenkinsRule.waitUntilNoActivityUpTo(60000);

        RunList<FreeStyleBuild> builds = project.getBuilds();
        for(FreeStyleBuild b : builds) {
             String console = jenkinsRule.createWebClient().getPage(b, "console").asText();
             System.out.println(console);
        }

        /**********************************************************************
         * Verify integration in different aspect like commit message content
         * and actual commits
         **********************************************************************/
        
        // Verify number of commits - first count on master after integration
        gitrepo.checkout().setName("master").call();
        gitrepo.checkout().setName("master").setUpstreamMode(SetupUpstreamMode.TRACK).call(); 
        gitrepo.pull().call();
        int commitsOnMasterAfterIntegration = TestUtilsFactory.countCommitsOnBranch(gitrepo, "master");
        gitrepo.close();
        
        /*        
        After the accumulated commit of the two commits 7933d8b, 4451bda on
        branch ready/myfeature it will look like this:
        ----------------------------------------------------------------------------
        *   49939e9 - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/myfeature': <John Doe>
        |\  
        | * 4451bda - (origin/ready/myfeature, ready/myfeature) Updated infofile file again on branch ready/myfeature <john Doe>
        | * 7933d8b - Updated infofile file on branch ready/myfeature <john Doe>
        |/  
        * 7770f99 - Updated infofile file on branch master <john Doe>
        * bb407fc - Readme file created on branch master <john Doe>
        ----------------------------------------------------------------------------
        */
        // All commits end on master, and there is a merge commit
        assertEquals(5, commitsOnMasterAfterIntegration);

        
        // using our little build result validator, see which string the head
        // commit on master contains. Head commit will in this case be the
        // new accumulated commit.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("Updated readme file on branch %s", FEATURE_BRANCH_NAME),
                    String.format("Updated readme file again on branch %s", FEATURE_BRANCH_NAME),
                    "- my first change is about this",
                    "- my next change is a refactor"
            ).retain().validate();
        }
        
        // Verifying commit SHAs are included correctly in the accumulated commit
        // by checking the SHAs are mentioned in the commit message.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("commit %s", featureCommit1SHA),
                    String.format("commit %s", featureCommit2SHA)
            ).retain().validate();
        }
        
        // validate file contents also
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readme, "First line in readme file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readme, "Second line in readme file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readme, String.format("Third line in readme file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readme, String.format("Fourth line in readme file, done on branch %s", FEATURE_BRANCH_NAME)));
    }
    
    
    
    
    
    
    /*
    Test flow
    * construct repository, with feature branch based on master (see below)
    * add a commit on master
    * make accumulated merge
    * verify that merge commit message contains the relevant commits

    Verification is done by searching the merge commit message for unique strings,
    which is supposed to be there because the accumulated commits have these 
    in their commit messages.
    
    Test also verified expected number of commits on master, after integration.
    
    This scenario is introduced to test that the walk of the git commit tree
    that collects the commit messages doesn't include commit on master.
    
    The constructed repository looks like this seen from the master branch
    AFTER integration:
    ----------------------------------------------------------------------------
    *   3962e0d - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/anotherNewFeature': (14 seconds ago) <john Doe>
    |\  
    | * 28ea8c9 - (origin/ready/anotherNewFeature, ready/anotherNewFeature) Updated info file again on branch ready/anotherNewFeature (23 seconds ago) <john Doe>
    | * 14699c5 - Updated info file on branch ready/anotherNewFeature (23 seconds ago) <john Doe>
    * | a0038a7 - Added an info2 file on branch master (23 seconds ago) <john Doe>
    |/  
    * 756e21f - Updated info file on branch master (23 seconds ago) <john Doe>
    * 1eeabe2 - info file created on branch master (23 seconds ago) <john Doe>
    ----------------------------------------------------------------------------
    
    The last commit is the accumulated commit. The second last is the one on
    master that was made after the feature branched off.
    Git log shows:
    ----------------------------------------------------------------------------
    commit 3962e0de4b263e7938b515820b4e15a61259d5af
    Merge: a0038a7 28ea8c9
    Author: john Doe <Joh@praqma.net>
    Date:   Mon Mar 2 20:56:01 2015 +0100

        Accumulated commit of the following from branch 'origin/ready/anotherNewFeature':

        commit 28ea8c98e891954e8c3e3e70e9dc61fb6e2919f2
        Author: john Doe <Joh@praqma.net>
        Date:   Mon Mar 02 08:55:52 2015 +0100

            Updated info file again on branch ready/anotherNewFeature

            - my first change is about this
            - my next change is a refactor.

        commit 14699c55596c25de1ffe881809aaac877992e6c9
        Author: john Doe <Joh@praqma.net>
        Date:   Mon Mar 02 08:55:52 2015 +0100

            Updated info file on branch ready/anotherNewFeature

    commit a0038a7ad69ec0013013171de8958f95e0726066
    Author: john Doe <Joh@praqma.net>
    Date:   Mon Mar 2 20:55:52 2015 +0100

        Added an info2 file on branch master
    ----------------------------------------------------------------------------
    */
    @Test
    public void mergeCommitContainsAllMessagesFromTheFeatureBranchButNotTheNewestOnMaster() throws Exception {

        /**********************************************************************
         * Prepare repository to use for testing
         **********************************************************************/
        String REPO_FOLDER_NAME = "mergeCommitContainsAllMessagesFromTheFeatureBranchButNotTheNewestOnMaster";
        String FEATURE_BRANCH_NAME = "ready/anotherNewFeature";

        File bareRepoPath = new File(REPO_FOLDER_NAME + ".git");
        bareRepository = new FileRepository(bareRepoPath);        
        bareRepository.create(true);
        
        File workingRepoPath = new File(REPO_FOLDER_NAME);

        // clone bare repository
        Git.cloneRepository().setURI("file:///"+bareRepoPath.getAbsolutePath()).setDirectory(workingRepoPath)
        .setBare(false)
        .setCloneAllBranches(true)                
        .setNoCheckout(false)
        .call().close();
        // Open it to add stuff below
        Git gitrepo = Git.open(workingRepoPath);

        // commits on branch master
        File infofile = new File(workingRepoPath,"info");
        FileUtils.writeStringToFile(infofile, String.format("First line in info file%n"), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        CommitCommand commitCommand = gitrepo.commit();
        commitCommand.setMessage("info file created on branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
     
        FileUtils.writeStringToFile(infofile, String.format("Second line in info file%n"), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage("Updated info file on branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
        

        // change to feature branch and do changes there
        CreateBranchCommand createBranchCommand = gitrepo.branchCreate();
        createBranchCommand.setName(FEATURE_BRANCH_NAME);
        createBranchCommand.call();
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();

        FileUtils.writeStringToFile(infofile, String.format("Third line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Updated info file on branch %s", FEATURE_BRANCH_NAME));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        RevCommit revCommit = commitCommand.call();
        String featureCommit1SHA = revCommit.getId().getName();
        System.out.println("featureCommit1SHA: " + featureCommit1SHA);

        FileUtils.writeStringToFile(infofile, String.format("Fourth line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        String multiLineCommitMessage = String.format("%n%n- my first change is about this%n- my next change is a refactor.");
        commitCommand.setMessage(String.format("Updated info file again on branch %s%s", FEATURE_BRANCH_NAME, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String featureCommit2SHA = revCommit.getId().getName();
        System.out.println("featureCommit2SHA: " + featureCommit2SHA);
        
        // commit on master again, new file to avoid merge conflict
        File infofile2 = new File(workingRepoPath,"info2");
        gitrepo.checkout().setName("master").call();
        FileUtils.writeStringToFile(infofile2, String.format("Added line to info2 file%n"), true);
        gitrepo.add().addFilepattern(infofile2.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage("Added an info2 file on branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
        

        // push all changes, so the end in the bare repository that our Jenkins test below will use
        gitrepo.push().setPushAll().call();        
        
        /**********************************************************************
         * Run test with Jenkins job trying to integrate the feature branch
         **********************************************************************/
        FreeStyleProject project = TestUtilsFactory.configurePretestedIntegrationPlugin(jenkinsRule, TestUtilsFactory.STRATEGY_TYPE.ACCUMULATED, bareRepository);
        TestUtilsFactory.triggerProject(project);
        jenkinsRule.waitUntilNoActivityUpTo(60000);

        RunList<FreeStyleBuild> builds = project.getBuilds();
        for(FreeStyleBuild b : builds) {
             String console = jenkinsRule.createWebClient().getPage(b, "console").asText();
             System.out.println(console);
        }

        /**********************************************************************
         * Verify integration in different aspect like commit message content
         * and actual commits
         **********************************************************************/
        
        // Verify number of commits - first count on master after integration
        gitrepo.checkout().setName("master").call();
        gitrepo.checkout().setName("master").setUpstreamMode(SetupUpstreamMode.TRACK).call(); 
        gitrepo.pull().call();
        int commitsOnMasterAfterIntegration = TestUtilsFactory.countCommitsOnBranch(gitrepo, "master");
        gitrepo.close();
        
        /*        
        The constructed repository looks like this seen from the master branch
        AFTER integration:
        ----------------------------------------------------------------------------
        *   3962e0d - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/anotherNewFeature': (14 seconds ago) <john Doe>
        |\  
        | * 28ea8c9 - (origin/ready/anotherNewFeature, ready/anotherNewFeature) Updated info file again on branch ready/anotherNewFeature (23 seconds ago) <john Doe>
        | * 14699c5 - Updated info file on branch ready/anotherNewFeature (23 seconds ago) <john Doe>
        * | a0038a7 - Added an info2 file on branch master (23 seconds ago) <john Doe>
        |/  
        * 756e21f - Updated info file on branch master (23 seconds ago) <john Doe>
        * 1eeabe2 - info file created on branch master (23 seconds ago) <john Doe>
        ----------------------------------------------------------------------------
        */
        assertEquals(6, commitsOnMasterAfterIntegration);

        
        // using our little build result validator, see which string the head
        // commit on master contains. Head commit will in this case be the
        // new accumulated commit.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("Updated info file on branch %s", FEATURE_BRANCH_NAME),
                    String.format("Updated info file again on branch %s", FEATURE_BRANCH_NAME),
                    "- my first change is about this",
                    "- my next change is a refactor"
            ).retain().validate();
        }
        
        // Verifying commit SHAs are included correctly in the accumulated commit
        // by checking the SHAs are mentioned in the commit message.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("commit %s", featureCommit1SHA),
                    String.format("commit %s", featureCommit2SHA)
            ).retain().validate();
        }
        
        // validate file contents also
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, "First line in info file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, "Second line in info file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("Third line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("Fourth line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
    }
    
    /*
    Test flow
    * construct repository as below
    * make accumulated merge
    * verify that merge commit message contains the relevant commits

    Verification is done by searching the merge commit message for unique strings,
    which is supposed to be there because the accumulated commits have these 
    in their commit messages.
    
    Test also verified expected number of commits on master, after integration.
    
    This scenario should ensure that commits merged into this branch is also
    part of the commit message as they will be part of the commit also.
   
    
    The constructed repository look like this BEFORE pretested integration with
    accumulated strategy:
    ----------------------------------------------------------------------------
    * 987ea39 - (HEAD, origin/ready/teamFeature, ready/teamFeature) Updated info file 5. time on branch ready/teamFeature (41 seconds ago) <john Doe>
    *   a94de58 - Merge commit '848c5758a6e201a4399e5196573b3e453068a17d' into ready/teamFeature (41 seconds ago) <john Doe>
    |\  
    | * 848c575 - (origin/master, master) Added an info2 file on branch master (41 seconds ago) <john Doe>
    * | 1b05c80 - 4. time updating info file on branch ready/teamFeature (41 seconds ago) <john Doe>
    * | 0f1add0 - Updated info file again on branch ready/teamFeature (41 seconds ago) <john Doe>
    * | 5f1888f - Updated info file on branch ready/teamFeature (41 seconds ago) <john Doe>
    |/  
    * f29de5a - info file created on branch master (41 seconds ago) <john Doe>
    ----------------------------------------------------------------------------
    
    ... and git log shows:
    ----------------------------------------------------------------------------
    commit 987ea39462b3f729403797be86b6cd5d84c02fb4
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Updated info file 5. time on branch ready/teamFeature

    commit a94de58e16bf3f80f99308d4485ba2d351b2e3c4
    Merge: 1b05c80 848c575
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Merge commit '848c5758a6e201a4399e5196573b3e453068a17d' into ready/teamFeature

    commit 1b05c80f10b65de021fd9437e287d2ac2b1ed176
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        4. time updating info file on branch ready/teamFeature

    commit 848c5758a6e201a4399e5196573b3e453068a17d
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Added an info2 file on branch master

    commit 0f1add021871a07e1427ceaa0ed8eb1727a9c71f
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Updated info file again on branch ready/teamFeature

        - my first change is about this
        - my next change is a refactor.

    commit f29de5a5db52ce8ed85eadc2eec9b48e11eea7a2
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        info file created on branch master

    commit 5f1888f216000280431c09192f1fa70a7c1a7265
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Updated info file on branch ready/teamFeature
    ----------------------------------------------------------------------------
    
    AFTER the accumulated merge, the tree looks like this:
    ----------------------------------------------------------------------------
    *   b60275a - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/teamFeature': (7 minutes ago) <john Doe>
    |\  
    | * 987ea39 - (origin/ready/teamFeature, ready/teamFeature) Updated info file 5. time on branch ready/teamFeature (38 minutes ago) <john Doe>
    | *   a94de58 - Merge commit '848c5758a6e201a4399e5196573b3e453068a17d' into ready/teamFeature (38 minutes ago) <john Doe>
    | |\  
    | |/  
    |/|   
    * | 848c575 - Added an info2 file on branch master (38 minutes ago) <john Doe>
    | * 1b05c80 - 4. time updating info file on branch ready/teamFeature (38 minutes ago) <john Doe>
    | * 0f1add0 - Updated info file again on branch ready/teamFeature (38 minutes ago) <john Doe>
    | * 5f1888f - Updated info file on branch ready/teamFeature (38 minutes ago) <john Doe>
    |/  
    * f29de5a - info file created on branch master (38 minutes ago) <john Doe>
    ----------------------------------------------------------------------------
    
    
    ... and git log shows:
    ----------------------------------------------------------------------------
    commit b60275a5543cd5de77ab631b36a4130e3f6e6e9b
    Merge: 848c575 987ea39
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 11:25:52 2015 +0100

        Accumulated commit of the following from branch 'origin/ready/teamFeature':

        commit 987ea39462b3f729403797be86b6cd5d84c02fb4
        Author: john Doe <Joh@praqma.net>
        Date:   Wed Mar 04 10:55:14 2015 +0100

            Updated info file 5. time on branch ready/teamFeature

        commit a94de58e16bf3f80f99308d4485ba2d351b2e3c4
        Author: john Doe <Joh@praqma.net>
        Date:   Wed Mar 04 10:55:14 2015 +0100

            Merge commit '848c5758a6e201a4399e5196573b3e453068a17d' into ready/teamFeature

        commit 1b05c80f10b65de021fd9437e287d2ac2b1ed176
        Author: john Doe <Joh@praqma.net>
        Date:   Wed Mar 04 10:55:14 2015 +0100

            4. time updating info file on branch ready/teamFeature

        commit 0f1add021871a07e1427ceaa0ed8eb1727a9c71f
        Author: john Doe <Joh@praqma.net>
        Date:   Wed Mar 04 10:55:14 2015 +0100

            Updated info file again on branch ready/teamFeature

            - my first change is about this
            - my next change is a refactor.

        commit 5f1888f216000280431c09192f1fa70a7c1a7265
        Author: john Doe <Joh@praqma.net>
        Date:   Wed Mar 04 10:55:14 2015 +0100

            Updated info file on branch ready/teamFeature

    commit 848c5758a6e201a4399e5196573b3e453068a17d
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Added an info2 file on branch master

    commit 987ea39462b3f729403797be86b6cd5d84c02fb4
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Updated info file 5. time on branch ready/teamFeature

    commit f29de5a5db52ce8ed85eadc2eec9b48e11eea7a2
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        info file created on branch master

    commit a94de58e16bf3f80f99308d4485ba2d351b2e3c4
    Merge: 1b05c80 848c575
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Merge commit '848c5758a6e201a4399e5196573b3e453068a17d' into ready/teamFeature

    commit 1b05c80f10b65de021fd9437e287d2ac2b1ed176
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        4. time updating info file on branch ready/teamFeature

    commit 0f1add021871a07e1427ceaa0ed8eb1727a9c71f
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Updated info file again on branch ready/teamFeature

        - my first change is about this
        - my next change is a refactor.

    commit 5f1888f216000280431c09192f1fa70a7c1a7265
    Author: john Doe <Joh@praqma.net>
    Date:   Wed Mar 4 10:55:14 2015 +0100

        Updated info file on branch ready/teamFeature
    ----------------------------------------------------------------------------
    */
    @Test
    public void mergeCommitContainsOnlyMessagesFromCorrectBranch() throws Exception {

        /**********************************************************************
         * Prepare repository to use for testing
         **********************************************************************/
        String REPO_FOLDER_NAME = "mergeCommitContainsOnlyMessagesFromCorrectBranch";
        String FEATURE_BRANCH_NAME = "ready/teamFeature";

        File bareRepoPath = new File(REPO_FOLDER_NAME + ".git");
        bareRepository = new FileRepository(bareRepoPath);        
        bareRepository.create(true);

        File workingRepoPath = new File(REPO_FOLDER_NAME);

        // clone bare repository
        Git.cloneRepository().setURI("file:///"+bareRepoPath.getAbsolutePath()).setDirectory(workingRepoPath)
        .setBare(false)
        .setCloneAllBranches(true)                
        .setNoCheckout(false)
        .call().close();
        // Open it to add stuff below
        Git gitrepo = Git.open(workingRepoPath);

        // commits on branch master
        File infofile = new File(workingRepoPath,"info");
        FileUtils.writeStringToFile(infofile, String.format("1. line in info file%n"), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        CommitCommand commitCommand = gitrepo.commit();
        commitCommand.setMessage("info file created on branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
        
        // change to feature branch and do changes there
        CreateBranchCommand createBranchCommand = gitrepo.branchCreate();
        createBranchCommand.setName(FEATURE_BRANCH_NAME);
        createBranchCommand.call();
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();

        FileUtils.writeStringToFile(infofile, String.format("2. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Updated info file on branch %s", FEATURE_BRANCH_NAME));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        RevCommit revCommit = commitCommand.call();
        String featureCommit1SHA = revCommit.getId().getName();
        System.out.println("featureCommit1SHA: " + featureCommit1SHA);

        FileUtils.writeStringToFile(infofile, String.format("3. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        String multiLineCommitMessage = String.format("%n%n- my first change is about this%n- my next change is a refactor.");
        commitCommand.setMessage(String.format("Updated info file again on branch %s%s", FEATURE_BRANCH_NAME, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String featureCommit2SHA = revCommit.getId().getName();
        System.out.println("featureCommit2SHA: " + featureCommit2SHA);
        
        // commit on master again, new file to avoid merge conflict
        File infofile2 = new File(workingRepoPath,"info2");
        gitrepo.checkout().setName("master").call();
        FileUtils.writeStringToFile(infofile2, String.format("Added line to info2 file%n"), true);
        gitrepo.add().addFilepattern(infofile2.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage("Added an info2 file on branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        RevCommit newCommitIdOnMaster = commitCommand.call();

        
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();
        FileUtils.writeStringToFile(infofile, String.format("4. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        multiLineCommitMessage = String.format("%n%n- major refactoring of tests%n- boring adding new lines");
        commitCommand.setMessage(String.format("4. time updating info file on branch %s", FEATURE_BRANCH_NAME, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String featureCommit3SHA = revCommit.getId().getName();
        System.out.println("featureCommit3SHA: " + featureCommit3SHA);
        
        MergeCommand mc = gitrepo.merge();
        mc.include(newCommitIdOnMaster);
        mc.setFastForward(MergeCommand.FastForwardMode.FF);
        mc.call();
        
        
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();
        FileUtils.writeStringToFile(infofile, String.format("5. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Updated info file 5. time on branch %s", FEATURE_BRANCH_NAME));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String featureCommit4SHA = revCommit.getId().getName();
        System.out.println("featureCommit4SHA: " + featureCommit4SHA);
        

        // push all changes, so the end in the bare repository that our Jenkins test below will use
        gitrepo.push().setPushAll().call();        
       
        /**********************************************************************
         * Run test with Jenkins job trying to integrate the feature branch
         **********************************************************************/
        FreeStyleProject project = TestUtilsFactory.configurePretestedIntegrationPlugin(jenkinsRule, TestUtilsFactory.STRATEGY_TYPE.ACCUMULATED, bareRepository);
        TestUtilsFactory.triggerProject(project);
        jenkinsRule.waitUntilNoActivityUpTo(60000);

        RunList<FreeStyleBuild> builds = project.getBuilds();
        for(FreeStyleBuild b : builds) {
             String console = jenkinsRule.createWebClient().getPage(b, "console").asText();
             System.out.println(console);
        }

        /**********************************************************************
         * Verify integration in different aspect like commit message content
         * and actual commits
         **********************************************************************/
        
        // Verify number of commits - first count on master after integration
        gitrepo.checkout().setName("master").call();
        gitrepo.checkout().setName("master").setUpstreamMode(SetupUpstreamMode.TRACK).call(); 
        gitrepo.pull().call();
        gitrepo.close();
        

    /*
        AFTER the accumulated merge, the tree looks like this:
        ----------------------------------------------------------------------------
        *   b60275a - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/teamFeature': (7 minutes ago) <john Doe>
        |\  
        | * 987ea39 - (origin/ready/teamFeature, ready/teamFeature) Updated info file 5. time on branch ready/teamFeature (38 minutes ago) <john Doe>
        | *   a94de58 - Merge commit '848c5758a6e201a4399e5196573b3e453068a17d' into ready/teamFeature (38 minutes ago) <john Doe>
        | |\  
        | |/  
        |/|   
        * | 848c575 - Added an info2 file on branch master (38 minutes ago) <john Doe>
        | * 1b05c80 - 4. time updating info file on branch ready/teamFeature (38 minutes ago) <john Doe>
        | * 0f1add0 - Updated info file again on branch ready/teamFeature (38 minutes ago) <john Doe>
        | * 5f1888f - Updated info file on branch ready/teamFeature (38 minutes ago) <john Doe>
        |/  
        * f29de5a - info file created on branch master (38 minutes ago) <john Doe>
        ----------------------------------------------------------------------------
        */
        int commitsOnMasterAfterIntegration = TestUtilsFactory.countCommitsOnBranch(gitrepo, "master");
        // All commits end on master after integration
        assertEquals(8, commitsOnMasterAfterIntegration);
        
        
        
        // using our little build result validator, see which string the head
        // commit on master contains. Head commit will in this case be the
        // new accumulated commit.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("Updated info file on branch %s", FEATURE_BRANCH_NAME),
                    String.format("Updated info file again on branch %s", FEATURE_BRANCH_NAME),
                    "- my first change is about this",
                    "- my next change is a refactor"
            ).retain().validate();
        }
        
        // Verifying commit SHAs are included correctly in the accumulated commit
        // by checking the SHAs are mentioned in the commit message.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("commit %s", featureCommit1SHA),
                    String.format("commit %s", featureCommit2SHA),
                    String.format("commit %s", featureCommit3SHA),
                    String.format("commit %s", featureCommit4SHA)
            ).retain().validate();
        }
        
        
        // validate file contents also
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, "1. line in info file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("2. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("3. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("4. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("5. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
    }


    
    
    /*
    Test flow
    * construct repository as below
    * make accumulated merge
    * verify that merge commit message contains the relevant commits

    Verification is done by searching the merge commit message for unique strings,
    which is supposed to be there because the accumulated commits have these 
    in their commit messages.
    
    Test also verified expected number of commits on master, after integration.
    
    Two featurebranches, only commit messages from the correct branch should be 
    used.
    
    
    The constructed repository look like this BEFORE pretested integration with
    accumulated strategy:
    ----------------------------------------------------------------------------
    * 6e7cf65 - (origin/ready/feature42, ready/feature42) Commit no. 8 in time, branch ready/feature42 (24 seconds ago) <john Doe>
    *   6504bd6 - Merge commit '2c63ce12883a711dd705fae3d3d49f5e979c7162' into ready/feature42 (24 seconds ago) <john Doe>
    |\  
    | * 2c63ce1 - (origin/ready/feature1337, ready/feature1337) Commit no. 6 in time, branch ready/feature1337 (24 seconds ago) <john Doe>
    | * 6233fc8 - Commit no. 5 in time, branch ready/feature1337 (24 seconds ago) <john Doe>
    | * cd06527 - (HEAD, origin/master, master) Commit no. 4 in time, branch master (24 seconds ago) <john Doe>
    * | 507bee5 - Commit no. 3 in time, branch ready/feature42 (24 seconds ago) <john Doe>
    * | 0c8cdd9 - Commit no. 2 in time, branch ready/feature42 (24 seconds ago) <john Doe>
    |/  
    * 0698fdd - Commit no. 1 in time, branch master) (24 seconds ago) <john Doe>
    ----------------------------------------------------------------------------
    
    AFTER the accumulated merge, the tree looks like this:
    ----------------------------------------------------------------------------
    *   1d48b3e - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/feature42': (28 seconds ago) <john Doe>
    |\  
    | * 6e7cf65 - (origin/ready/feature42, ready/feature42) Commit no. 8 in time, branch ready/feature42 (2 minutes ago) <john Doe>
    | *   6504bd6 - Merge commit '2c63ce12883a711dd705fae3d3d49f5e979c7162' into ready/feature42 (2 minutes ago) <john Doe>
    | |\  
    | | * 2c63ce1 - (origin/ready/feature1337, ready/feature1337) Commit no. 6 in time, branch ready/feature1337 (2 minutes ago) <john Doe>
    | | * 6233fc8 - Commit no. 5 in time, branch ready/feature1337 (2 minutes ago) <john Doe>
    | |/  
    |/|   
    * | cd06527 - Commit no. 4 in time, branch master (2 minutes ago) <john Doe>
    | * 507bee5 - Commit no. 3 in time, branch ready/feature42 (2 minutes ago) <john Doe>
    | * 0c8cdd9 - Commit no. 2 in time, branch ready/feature42 (2 minutes ago) <john Doe>
    |/  
    * 0698fdd - Commit no. 1 in time, branch master) (2 minutes ago) <john Doe>  
    ----------------------------------------------------------------------------
    
    
    ... and 'git log -n2' shows (last two commit message):
    ----------------------------------------------------------------------------
    commit 1d48b3e1504e4c21ea84025d458bfd7d2ec0b286
    Merge: cd06527 6e7cf65
    Author: john Doe <Joh@praqma.net>
    Date:   Thu Mar 5 15:04:11 2015 +0100

        Accumulated commit of the following from branch 'origin/ready/feature42':

        commit 6e7cf65bc87f5a3f666889090c8ee96ef701bef4
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:02:45 2015 +0100

            Commit no. 8 in time, branch ready/feature42

        commit 6504bd689ca748736e4f9cc22bdbcc941617fb48
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:02:45 2015 +0100

            Merge commit '2c63ce12883a711dd705fae3d3d49f5e979c7162' into ready/feature42

        commit 2c63ce12883a711dd705fae3d3d49f5e979c7162
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:02:45 2015 +0100

            Commit no. 6 in time, branch ready/feature1337

        commit 507bee5832d9a4ca7266be99aa455c8c0e65f48d
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:02:45 2015 +0100

            Commit no. 3 in time, branch ready/feature42

            - my first change is about this
            - my next change is a refactor.

        commit 6233fc804d4ee1e9507bd221eaa78ba853ca038d
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:02:45 2015 +0100

            Commit no. 5 in time, branch ready/feature1337

        commit 0c8cdd9585c9faf3a4d4732982ad0edc0550268d
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:02:45 2015 +0100

            Commit no. 2 in time, branch ready/feature42

    commit cd065279e47571f9b4cf451e2ce535d9419d7a81
    Author: john Doe <Joh@praqma.net>
    Date:   Thu Mar 5 15:02:45 2015 +0100

        Commit no. 4 in time, branch master
    ----------------------------------------------------------------------------        
    */
    // Purpose, test our treewalk doesn't end up on other branches
    // that won't be merged in, but they are connect they need to be included.
    @Test
    public void commitMessageShouldOnlyCollectFromOwnBranch() throws Exception {

        /**********************************************************************
         * Prepare repository to use for testing
         **********************************************************************/
        String REPO_FOLDER_NAME = "commitMessageShouldOnlyCollectFromOwnBranch";
        String FEATURE_BRANCH_NAME = "ready/feature42";
        String FEATURE_BRANCH_NAME2 = "ready/feature1337";

        File bareRepoPath = new File(REPO_FOLDER_NAME + ".git");
        bareRepository = new FileRepository(bareRepoPath);        
        bareRepository.create(true);

        File workingRepoPath = new File(REPO_FOLDER_NAME);

        // clone bare repository
        Git.cloneRepository().setURI("file:///"+bareRepoPath.getAbsolutePath()).setDirectory(workingRepoPath)
        .setBare(false)
        .setCloneAllBranches(true)                
        .setNoCheckout(false)
        .call().close();
        // Open it to add stuff below
        Git gitrepo = Git.open(workingRepoPath);

        // commits on branch master
        File readmefile = new File(workingRepoPath,"readme");
        FileUtils.writeStringToFile(readmefile, String.format("1. line in readme file%n"), true);
        gitrepo.add().addFilepattern(readmefile.getName()).call();
        CommitCommand commitCommand = gitrepo.commit();
        commitCommand.setMessage("Commit no. 1 in time, branch master)");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
        
        // change to feature branch and do changes there
        CreateBranchCommand createBranchCommand = gitrepo.branchCreate();
        createBranchCommand.setName(FEATURE_BRANCH_NAME);
        createBranchCommand.call();
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();

        File infofile = new File(workingRepoPath,"info");
        FileUtils.writeStringToFile(infofile, String.format("2. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Commit no. 2 in time, branch %s", FEATURE_BRANCH_NAME));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        RevCommit revCommit = commitCommand.call();
        String feature42Commit1SHA = revCommit.getId().getName();
        System.out.println("feature42Commit1SHA: " + feature42Commit1SHA);

        FileUtils.writeStringToFile(infofile, String.format("3. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        String multiLineCommitMessage = String.format("%n%n- my first change is about this%n- my next change is a refactor.");
        commitCommand.setMessage(String.format("Commit no. 3 in time, branch %s%s", FEATURE_BRANCH_NAME, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String feature42Commit2SHA = revCommit.getId().getName();
        System.out.println("feature42Commit2SHA: " + feature42Commit2SHA);
        
        // commit on master again, new file to avoid merge conflict
        gitrepo.checkout().setName("master").call();
        FileUtils.writeStringToFile(readmefile, String.format("Added line to readme file%n"), true);
        gitrepo.add().addFilepattern(readmefile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage("Commit no. 4 in time, branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String masterCommit2SHA = revCommit.getId().getName();
        System.out.println("masterCommit2SHA: " + masterCommit2SHA);
        
        // change to feature branch and do changes there
        createBranchCommand = gitrepo.branchCreate();
        createBranchCommand.setName(FEATURE_BRANCH_NAME2);
        createBranchCommand.call();
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME2).call();
        File txtfile = new File(workingRepoPath,"txt");
        FileUtils.writeStringToFile(txtfile, String.format("1. line in txt file, done on branch %s%n", FEATURE_BRANCH_NAME2), true);
        gitrepo.add().addFilepattern(txtfile.getName()).call();
        commitCommand = gitrepo.commit();
        multiLineCommitMessage = String.format("%n%n- major refactoring of tests%n- boring adding new lines");
        commitCommand.setMessage(String.format("Commit no. 5 in time, branch %s", FEATURE_BRANCH_NAME2, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String feature1337Commit1SHA = revCommit.getId().getName();
        System.out.println("feature1337Commit1SHA: " + feature1337Commit1SHA);
        
        FileUtils.writeStringToFile(txtfile, String.format("2. line in txt file, done on branch %s%n", FEATURE_BRANCH_NAME2), true);
        gitrepo.add().addFilepattern(txtfile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Commit no. 6 in time, branch %s", FEATURE_BRANCH_NAME2));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        RevCommit lastCommitOnfeature1337 = commitCommand.call();
        String feature1337Commit2SHA = lastCommitOnfeature1337.getId().getName();
        System.out.println("feature1337Commit2SHA: " + feature1337Commit2SHA);
        
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();
        MergeCommand mc = gitrepo.merge();
        mc.include(lastCommitOnfeature1337);
        mc.setFastForward(MergeCommand.FastForwardMode.FF);
        mc.call();
        
        FileUtils.writeStringToFile(infofile, String.format("4. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Commit no. 8 in time, branch %s", FEATURE_BRANCH_NAME));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String feature42Commit3SHA = revCommit.getId().getName();
        System.out.println("feature42Commit3SHA: " + feature42Commit3SHA);
        

        // push all changes, so the end in the bare repository that our Jenkins test below will use
        gitrepo.push().setPushAll().call();        

        
        /**********************************************************************
         * Run test with Jenkins job trying to integrate the feature branch
         **********************************************************************/
        FreeStyleProject project = TestUtilsFactory.configurePretestedIntegrationPlugin(jenkinsRule, TestUtilsFactory.STRATEGY_TYPE.ACCUMULATED, bareRepository);
        TestUtilsFactory.triggerProject(project);
        jenkinsRule.waitUntilNoActivityUpTo(60000);

        RunList<FreeStyleBuild> builds = project.getBuilds();
        for(FreeStyleBuild b : builds) {
             String console = jenkinsRule.createWebClient().getPage(b, "console").asText();
             System.out.println(console);
        }

        /**********************************************************************
         * Verify integration in different aspect like commit message content
         * and actual commits
         **********************************************************************/
        
        // Verify number of commits - first count on master after integration
        gitrepo.checkout().setName("master").call();
        gitrepo.checkout().setName("master").setUpstreamMode(SetupUpstreamMode.TRACK).call(); 
        gitrepo.pull().call();
        gitrepo.close();
        
    /*
        AFTER the accumulated merge, the tree looks like this:
        ----------------------------------------------------------------------------
            *   1d48b3e - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/feature42': (28 seconds ago) <john Doe>
            |\  
            | * 6e7cf65 - (origin/ready/feature42, ready/feature42) Commit no. 8 in time, branch ready/feature42 (2 minutes ago) <john Doe>
            | *   6504bd6 - Merge commit '2c63ce12883a711dd705fae3d3d49f5e979c7162' into ready/feature42 (2 minutes ago) <john Doe>
            | |\  
            | | * 2c63ce1 - (origin/ready/feature1337, ready/feature1337) Commit no. 6 in time, branch ready/feature1337 (2 minutes ago) <john Doe>
            | | * 6233fc8 - Commit no. 5 in time, branch ready/feature1337 (2 minutes ago) <john Doe>
            | |/  
            |/|   
            * | cd06527 - Commit no. 4 in time, branch master (2 minutes ago) <john Doe>
            | * 507bee5 - Commit no. 3 in time, branch ready/feature42 (2 minutes ago) <john Doe>
            | * 0c8cdd9 - Commit no. 2 in time, branch ready/feature42 (2 minutes ago) <john Doe>
            |/  
            * 0698fdd - Commit no. 1 in time, branch master) (2 minutes ago) <john Doe>
        ----------------------------------------------------------------------------
        */
        int commitsOnMasterAfterIntegration = TestUtilsFactory.countCommitsOnBranch(gitrepo, "master");
        // All commits end on master after integration
        assertEquals(9, commitsOnMasterAfterIntegration);
        
        
        
        // using our little build result validator, see which string the head
        // commit on master contains. Head commit will in this case be the
        // new accumulated commit.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("Commit no. 2 in time, branch %s", FEATURE_BRANCH_NAME),
                    "- my first change is about this", "- my next change is a refactor.",
                    String.format("Commit no. 3 in time, branch %s", FEATURE_BRANCH_NAME),
                    String.format("Commit no. 5 in time, branch %s", FEATURE_BRANCH_NAME2),
                    String.format("Commit no. 6 in time, branch %s", FEATURE_BRANCH_NAME2),
                    String.format("Commit no. 8 in time, branch %s", FEATURE_BRANCH_NAME)
            ).retain().validate();
        }
        
        // Verifying commit SHAs are included correctly in the accumulated commit
        // by checking the SHAs are mentioned in the commit message.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("commit %s", feature42Commit1SHA),
                    String.format("commit %s", feature42Commit2SHA),
                    String.format("commit %s", feature42Commit3SHA),
                    String.format("commit %s", feature1337Commit1SHA),
                    String.format("commit %s", feature1337Commit2SHA)
            ).retain().validate();
        }
        
        // validate file contents also
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readmefile, "1. line in readme file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readmefile, "Added line to readme file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("2. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("3. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("4. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
    }
    
    
    
    
    
    
    
    
    
    /*
    Test flow
    * construct repository as below
    * make accumulated merge
    * verify that merge commit message contains the relevant commits

    Verification is done by searching the merge commit message for unique strings,
    which is supposed to be there because the accumulated commits have these 
    in their commit messages.
    
    Test also verified expected number of commits on master, after integration.
    
    Another scenario, that should make sure the walk of the git tree for building
    the commit message doesn't use commits from wrong branches.
    
    
    The constructed repository look like this BEFORE pretested integration with
    accumulated strategy:
    ----------------------------------------------------------------------------
    * c396366 - (origin/dev/disconnectedFeature, dev/disconnectedFeature) Commit no. 5 in time, branch dev/disconnectedFeature (46 seconds ago) <john Doe>
    * 934427d - Commit no. 4 in time, branch dev/disconnectedFeature (46 seconds ago) <john Doe>
    | * 2d67e2d - (HEAD, origin/master, master) Commit no. 6 in time, branch master (46 seconds ago) <john Doe>
    |/  
    | * f4e4aba - (origin/ready/mergeableFeature, ready/mergeableFeature) Commit no. 3 in time, branch ready/mergeableFeature (46 seconds ago) <john Doe>
    | * 64be8e4 - Commit no. 2 in time, branch ready/mergeableFeature (46 seconds ago) <john Doe>
    |/  
    * a44e12a - Commit no. 1 in time, branch master) (46 seconds ago) <john Doe>
    ----------------------------------------------------------------------------
    
    AFTER the accumulated merge, the tree looks like this:
    ----------------------------------------------------------------------------
    *   43515a4 - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/mergeableFeature': (32 seconds ago) <john Doe>
    |\  
    | * f4e4aba - (origin/ready/mergeableFeature, ready/mergeableFeature) Commit no. 3 in time, branch ready/mergeableFeature (3 minutes ago) <john Doe>
    | * 64be8e4 - Commit no. 2 in time, branch ready/mergeableFeature (3 minutes ago) <john Doe>
    * | 2d67e2d - Commit no. 6 in time, branch master (3 minutes ago) <john Doe>
    |/  
    | * c396366 - (origin/dev/disconnectedFeature, dev/disconnectedFeature) Commit no. 5 in time, branch dev/disconnectedFeature (3 minutes ago) <john Doe>
    | * 934427d - Commit no. 4 in time, branch dev/disconnectedFeature (3 minutes ago) <john Doe>
    |/  
    * a44e12a - Commit no. 1 in time, branch master) (3 minutes ago) <john Doe>
    ----------------------------------------------------------------------------
    
    
    ... and 'git log -n2' shows (last two commit message):
    ----------------------------------------------------------------------------
    commit 43515a48721209797a9f5e40518e28cde843b540
    Merge: 2d67e2d f4e4aba
    Author: john Doe <Joh@praqma.net>
    Date:   Thu Mar 5 15:52:49 2015 +0100

        Accumulated commit of the following from branch 'origin/ready/mergeableFeature':

        commit f4e4aba8ad1ad90dd5aad5cbdb82ed0df60f7d36
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:50:32 2015 +0100

            Commit no. 3 in time, branch ready/mergeableFeature

            - my first change is about this
            - my next change is a refactor.

        commit 64be8e49f7987dbb6be52051e7968158c9bea33e
        Author: john Doe <Joh@praqma.net>
        Date:   Thu Mar 05 03:50:32 2015 +0100

            Commit no. 2 in time, branch ready/mergeableFeature

    commit 2d67e2d4cc1d4b34ec5b98c2db163bab83da6896
    Author: john Doe <Joh@praqma.net>
    Date:   Thu Mar 5 15:50:32 2015 +0100

        Commit no. 6 in time, branch master

    ----------------------------------------------------------------------------        
    */
    // Purpose, test our treewalk doesn't end up on other branches
    // that won't be merged in...
    @Test
    public void commitMessageShouldOnCollectFromConnectedBranches() throws Exception {

        /**********************************************************************
         * Prepare repository to use for testing
         **********************************************************************/
        String REPO_FOLDER_NAME = "commitMessageShouldOnCollectFromConnectedBranches";
        String FEATURE_BRANCH_NAME = "ready/mergeableFeature";
        String FEATURE_BRANCH_NAME2 = "dev/disconnectedFeature";

        File bareRepoPath = new File(REPO_FOLDER_NAME + ".git");
        bareRepository = new FileRepository(bareRepoPath);        
        bareRepository.create(true);

        File workingRepoPath = new File(REPO_FOLDER_NAME);

        // clone bare repository
        Git.cloneRepository().setURI("file:///"+bareRepoPath.getAbsolutePath()).setDirectory(workingRepoPath)
        .setBare(false)
        .setCloneAllBranches(true)                
        .setNoCheckout(false)
        .call().close();
        // Open it to add stuff below
        Git gitrepo = Git.open(workingRepoPath);

        // commits on branch master
        File readmefile = new File(workingRepoPath,"readme");
        FileUtils.writeStringToFile(readmefile, String.format("1. line in readme file%n"), true);
        gitrepo.add().addFilepattern(readmefile.getName()).call();
        CommitCommand commitCommand = gitrepo.commit();
        commitCommand.setMessage("Commit no. 1 in time, branch master)");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        commitCommand.call();
        
        // change to feature branch and do changes there
        CreateBranchCommand createBranchCommand = gitrepo.branchCreate();
        createBranchCommand.setName(FEATURE_BRANCH_NAME);
        createBranchCommand.call();
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME).call();

        File infofile = new File(workingRepoPath,"info");
        FileUtils.writeStringToFile(infofile, String.format("2. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Commit no. 2 in time, branch %s", FEATURE_BRANCH_NAME));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        RevCommit revCommit = commitCommand.call();
        String mergeableFeatureCommit1SHA = revCommit.getId().getName();
        System.out.println("mergeableFeatureCommit1SHA: " + mergeableFeatureCommit1SHA);

        FileUtils.writeStringToFile(infofile, String.format("3. line in info file, done on branch %s%n", FEATURE_BRANCH_NAME), true);
        gitrepo.add().addFilepattern(infofile.getName()).call();
        commitCommand = gitrepo.commit();
        String multiLineCommitMessage = String.format("%n%n- my first change is about this%n- my next change is a refactor.");
        commitCommand.setMessage(String.format("Commit no. 3 in time, branch %s%s", FEATURE_BRANCH_NAME, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String mergeableFeatureCommit2SHA = revCommit.getId().getName();
        System.out.println("mergeableFeatureCommit2SHA: " + mergeableFeatureCommit2SHA);
        
        
        // change to feature branch and do changes there
        gitrepo.checkout().setName("master").call();
        createBranchCommand = gitrepo.branchCreate();
        createBranchCommand.setName(FEATURE_BRANCH_NAME2);
        createBranchCommand.call();
        gitrepo.checkout().setName(FEATURE_BRANCH_NAME2).call();
        File txtfile = new File(workingRepoPath,"txt");
        FileUtils.writeStringToFile(txtfile, String.format("1. line in txt file, done on branch %s%n", FEATURE_BRANCH_NAME2), true);
        gitrepo.add().addFilepattern(txtfile.getName()).call();
        commitCommand = gitrepo.commit();
        multiLineCommitMessage = String.format("%n%n- major refactoring of tests%n- boring adding new lines");
        commitCommand.setMessage(String.format("Commit no. 4 in time, branch %s", FEATURE_BRANCH_NAME2, multiLineCommitMessage));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String disconnectedFeatureCommit1SHA = revCommit.getId().getName();
        System.out.println("disconnectedFeatureCommit1SHA: " + disconnectedFeatureCommit1SHA);
        
        FileUtils.writeStringToFile(txtfile, String.format("2. line in txt file, done on branch %s%n", FEATURE_BRANCH_NAME2), true);
        gitrepo.add().addFilepattern(txtfile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage(String.format("Commit no. 5 in time, branch %s", FEATURE_BRANCH_NAME2));
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String disconnectedFeatureCommit2SHA = revCommit.getId().getName();
        System.out.println("disconnectedFeatureCommit2SHA: " + disconnectedFeatureCommit2SHA);
        
        // commit on master again, new file to avoid merge conflict
        gitrepo.checkout().setName("master").call();
        FileUtils.writeStringToFile(readmefile, String.format("Added line to readme file%n"), true);
        gitrepo.add().addFilepattern(readmefile.getName()).call();
        commitCommand = gitrepo.commit();
        commitCommand.setMessage("Commit no. 6 in time, branch master");
        commitCommand.setAuthor(AUTHOR_NAME, AUTHOR_EMAIL);
        // make the commit
        revCommit = commitCommand.call();
        String masterCommit2SHA = revCommit.getId().getName();
        System.out.println("masterCommit2SHA: " + masterCommit2SHA);
        
        // push all changes, so the end in the bare repository that our Jenkins test below will use
        gitrepo.push().setPushAll().call();        



        /**********************************************************************
         * Run test with Jenkins job trying to integrate the feature branch
         **********************************************************************/
        FreeStyleProject project = TestUtilsFactory.configurePretestedIntegrationPlugin(jenkinsRule, TestUtilsFactory.STRATEGY_TYPE.ACCUMULATED, bareRepository);
        TestUtilsFactory.triggerProject(project);
        jenkinsRule.waitUntilNoActivityUpTo(60000);

        RunList<FreeStyleBuild> builds = project.getBuilds();
        for(FreeStyleBuild b : builds) {
             String console = jenkinsRule.createWebClient().getPage(b, "console").asText();
             System.out.println(console);
        }

        /**********************************************************************
         * Verify integration in different aspect like commit message content
         * and actual commits
         **********************************************************************/
        
        // Verify number of commits - first count on master after integration
        gitrepo.checkout().setName("master").call();
        gitrepo.checkout().setName("master").setUpstreamMode(SetupUpstreamMode.TRACK).call(); 
        gitrepo.pull().call();
        gitrepo.close();
        
        
    /*
        AFTER the accumulated merge, the tree looks like this:
        ----------------------------------------------------------------------------
        *   43515a4 - (HEAD, origin/master, master) Accumulated commit of the following from branch 'origin/ready/mergeableFeature': (32 seconds ago) <john Doe>
        |\  
        | * f4e4aba - (origin/ready/mergeableFeature, ready/mergeableFeature) Commit no. 3 in time, branch ready/mergeableFeature (3 minutes ago) <john Doe>
        | * 64be8e4 - Commit no. 2 in time, branch ready/mergeableFeature (3 minutes ago) <john Doe>
        * | 2d67e2d - Commit no. 6 in time, branch master (3 minutes ago) <john Doe>
        |/  
        | * c396366 - (origin/dev/disconnectedFeature, dev/disconnectedFeature) Commit no. 5 in time, branch dev/disconnectedFeature (3 minutes ago) <john Doe>
        | * 934427d - Commit no. 4 in time, branch dev/disconnectedFeature (3 minutes ago) <john Doe>
        |/  
        * a44e12a - Commit no. 1 in time, branch master) (3 minutes ago) <john Doe>
        ----------------------------------------------------------------------------
        */

        int commitsOnMasterAfterIntegration = TestUtilsFactory.countCommitsOnBranch(gitrepo, "master");
        // All commits ends on master after integration
        assertEquals(5, commitsOnMasterAfterIntegration);
        
  
        
        // using our little build result validator, see which string the head
        // commit on master contains. Head commit will in this case be the
        // new accumulated commit.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("Commit no. 2 in time, branch %s", FEATURE_BRANCH_NAME),
                    "- my first change is about this", "- my next change is a refactor.",
                    String.format("Commit no. 3 in time, branch %s", FEATURE_BRANCH_NAME)
            ).retain().validate();
        }
        
        // Verifying commit SHAs are included correctly in the accumulated commit
        // by checking the SHAs are mentioned in the commit message.
        try (BuildResultValidator buildResultValidator = new BuildResultValidator(builds.getLastBuild(), bareRepository)) {
            buildResultValidator.hasHeadCommitContents(
                    String.format("commit %s", mergeableFeatureCommit1SHA),
                    String.format("commit %s", mergeableFeatureCommit2SHA)
            ).retain().validate();
        }
        
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readmefile, "1. line in readme file"));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("2. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(infofile, String.format("3. line in info file, done on branch %s", FEATURE_BRANCH_NAME)));
        assertEquals(true, TestUtilsFactory.checkForLineInFile(readmefile, "Added line to readme file"));
        
    }
        
}
